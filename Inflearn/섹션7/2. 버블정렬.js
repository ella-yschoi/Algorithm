function solution(arr) {
  let answer = arr;
  for (let i = 0; i < arr.length - 1; i++) {
    // 가장 끝자리는 자리 정했으니 길이보다 -2까지 순회
    for (let j = 0; j < arr.length - i - 1; j++) {
      if (arr[j] > arr[j + 1]){
        [arr[j], arr[j + 1]] = [arr[j + 1], arr[j]];
      }
    }   
  }
  return answer;
}

let arr=[13, 5, 11, 7, 23, 15];
console.log(solution(arr));

// TIL
  // 버블정렬 (오름차순)
  // 이웃한 두 수끼리 정렬해서 작으면 바꾸어주는 것
  // 계속 뒤로 밀고 들어오므로 가장 뒷자리가 가장 큰 숫자로 바뀌는 것이 버블정렬의 특징

  // 버블정렬 vs. 선택정렬
  // 1. 작동 방식
  // - 버블: 인접한 원소들을 비교하고 필요한 경우 위치를 교환한다. 이 과정을 여러 번 반복하면서 가장 큰 원소(또는 가장 작은 원소)가 배열의 맨 끝(또는 맨 앞)으로 "버블링" 즉, 떠오르게 한다. 각 단계마다 하나의 원소가 최종 위치로 이동한다.
  // - 선택: 각 단계에서 전체 배열(또는 부분 배열)에서 가장 작은 원소(또는 가장 큰 원소)를 찾고, 이를 해당 단계의 시작점의 원소와 교환한다. 즉, 각 단계마다 하나의 원소가 최종 위치로 정해진다.

  // 2. 효율성과 성능
  // - 버블: 일반적으로 효율적이지 않은 편이다. 최악의 경우(역순으로 정렬된 배열)에는 O(n²)의 시간 복잡도를 가진다. 하지만, 이미 정렬된 부분에 대해서는 추가 작업을 수행하지 않으므로 최선의 경우 O(n)의 시간 복잡도를 가질 수 있다.
  // - 선택: 버블 정렬과 비슷하게 대체적으로 효율적이지 않다. 선택 정렬의 시간 복잡도는 항상 O(n²)이며, 배열의 정렬 여부에 상관없이 성능이 일정하다.

  // 3. 안정성
  // - 버블: 안정적인 정렬 방법이다. 값이 같은 원소의 상대적 순서가 변경되지 않는다.
  // - 선택: 안정적이지 않다. 같은 값의 원소가 있을 때 그 순서가 바뀔 수 있다.

  // 4. 실용적 측면
  // - 버블: 구현이 간단하지만, 효율성이 떨어져서 대규모 데이터셋에는 적합하지 않다.
  // - 선택: 구현이 쉽고 메모리 사용이 적지만, 역시 대규모 데이터셋에는 적합하지 않다.
